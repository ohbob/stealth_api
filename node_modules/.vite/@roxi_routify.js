import "./chunk-3BQGYF6B.js";
import {
  derived,
  writable
} from "./chunk-M2CW7W2L.js";
import {
  getContext,
  get_store_value
} from "./chunk-EVFFEGSH.js";
import {
  __objRest,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __spreadProps,
  __spreadValues
} from "./chunk-PJ36OKPD.js";

// node_modules/@roxi/routify/lib/runtime/index.js
import Router2 from "/Users/def/Documents/GitHub/stealth_api/node_modules/@roxi/routify/lib/runtime/Router/Router.svelte";

// node_modules/@roxi/routify/lib/runtime/Route/RouteFragment.js
var _params;
var RouteFragment = class {
  constructor(route, node2, urlFragment) {
    __privateAdd(this, _params, {});
    this.route = route;
    this.node = node2;
    this.load = void 0;
    this.urlFragment = urlFragment;
    Object.defineProperty(this, "route", { enumerable: false });
  }
  get params() {
    return __privateGet(this, _params);
  }
  setParams(params2) {
    __privateSet(this, _params, params2);
  }
  getParamsFromFragment() {
    const { getFieldsFromName, getValuesFromPath, mapFieldsWithValues } = this.route.router.instance.utils;
    return mapFieldsWithValues(getFieldsFromName(this.node.name), getValuesFromPath(this.node.regex, this.urlFragment));
  }
};
_params = new WeakMap();

// node_modules/@roxi/routify/lib/runtime/Route/utils.js
var spreadsLast = (node2) => node2.name.match(/\[\.\.\.(.+)\]/) ? 1 : -1;
var getNearestAncestorNodeWithSpreadParam = (routeFragments) => {
  var _a;
  for (const fragment of [...routeFragments].reverse()) {
    for (const node2 of ((_a = fragment.node.parent) == null ? void 0 : _a.children) || []) {
      const match = node2.name.match(/\[\.\.\.(.+)\]/);
      if (match)
        return node2;
    }
  }
};
var getUrlFragments = (url2) => url2.replace(/[?#].+/, "").replace(/\/$/, "").split("/").slice(1);
var indexOfNode = (fragments, node2) => fragments.findIndex((fragment) => fragment.node === node2);

// node_modules/@roxi/routify/lib/runtime/Route/Route.js
var URL_STATES = ["pushState", "replaceState", "popState"];
var Route = class {
  constructor(router, url2, mode) {
    __publicField(this, "allFragments", []);
    __publicField(this, "loaded");
    __publicField(this, "invalid", null);
    this.router = router;
    this.url = url2;
    this.mode = mode;
    if (!router.rootNode) {
      this.router.log.error("Can't navigate without a rootNode");
      const err = new Error("Can't navigate without a rootNode");
      Object.assign(err, { routify: { router } });
      throw err;
    }
    if (!URL_STATES.includes(mode))
      throw new Error("url.mode must be pushState, replaceState or popState");
    this.allFragments = this._createFragments();
    this.log = router.log.createChild("[route]");
    this.log.debug("created", this);
  }
  get fragments() {
    return this.allFragments.filter((f) => f.node.module);
  }
  get params() {
    const match = this.url.match(/\?.+/);
    const query = match && match[0];
    return Object.assign({}, ...this.allFragments.map((fragment) => fragment.params), query && this.router.queryHandler.parse(query));
  }
  async loadRoute() {
    const { router } = this;
    const pipeline = [
      this.runBeforeUrlChangeHooks,
      this.loadComponents,
      this.runGuards,
      this.runPreloads
    ];
    this.loaded = new Promise(async (resolve, reject) => {
      for (const pretask of pipeline) {
        const passedPreTask = await pretask.bind(this)();
        const routerHasNewerPendingRoute = this !== router.pendingRoute.get();
        if (routerHasNewerPendingRoute) {
          router.pendingRoute.get().loaded.then(resolve).catch(reject);
        } else if (!passedPreTask) {
          router.pendingRoute.set(null);
          reject("pretask failed");
        }
        if (!passedPreTask || routerHasNewerPendingRoute)
          return;
      }
      this.router.log.debug("set active route", this);
      const $activeRoute = this.router.activeRoute.get();
      if ($activeRoute)
        router.history.push($activeRoute);
      router.activeRoute.set(this);
      const _history = [...router.history].reverse();
      router.afterUrlChange.run({ route: this }, _history);
      this.router.log.debug("unset pending route", this);
      router.pendingRoute.set(null);
      resolve({ route: this });
    });
    return this.loaded;
  }
  async loadComponents() {
    this.log.debug("load components", this);
    await Promise.all(this.fragments.map(async (fragment) => {
      const module = await fragment.node.module();
      fragment.node.module = () => module;
    }));
    return true;
  }
  async runPreloads() {
    this.log.debug("run preloads", this);
    const ctx = {
      route: this,
      node: [...this.fragments].pop().node
    };
    const promises = this.fragments.filter((fragment) => {
      var _a;
      return (_a = fragment.node.module()) == null ? void 0 : _a.load;
    }).map(async (fragment) => fragment.load = await fragment.node.module().load(ctx));
    await Promise.all(promises);
    return true;
  }
  async runGuards() {
    this.log.debug(`running guards for ${this.url}`, this);
    const components = this.fragments.map((fragment) => fragment.node.module()).filter((module) => module == null ? void 0 : module.guard);
    for (const module of components) {
      const result = await module.guard(this);
      if (!result || this.invalid)
        return false;
    }
    return true;
  }
  async runBeforeUrlChangeHooks() {
    return await this.router.beforeUrlChange.run({ route: this });
  }
  _createFragments() {
    const { url: url2 = "", router } = this;
    const { rootNode } = router;
    let currentSpreadParam = [];
    let currentNode = rootNode;
    const createFragment = (node2, urlFragment, spreadParam) => {
      const fragment = new RouteFragment(this, node2, urlFragment);
      const spreadMatch = node2.name.match(/\[\.\.\.(.+)\]/);
      if (spreadMatch)
        spreadParam.push(urlFragment);
      else
        spreadParam = [];
      if (spreadMatch)
        fragment.setParams({ [spreadMatch[1]]: spreadParam });
      else
        fragment.setParams(fragment.getParamsFromFragment());
      return fragment;
    };
    const urlFragments = getUrlFragments(url2);
    const routeFragments = [new RouteFragment(this, currentNode, "")];
    for (let ufIndex = 0; ufIndex < urlFragments.length; ufIndex++) {
      const urlFragment = urlFragments[ufIndex];
      const children = currentNode.children.filter((child2) => !child2.name.startsWith("_"));
      const child = children.find((child2) => child2.name === urlFragment) || children.sort(spreadsLast).find((child2) => child2.regex.test(urlFragment));
      if (child) {
        routeFragments.push(createFragment(child, urlFragment, currentSpreadParam));
        currentNode = child;
      } else if (currentSpreadParam.length) {
        currentSpreadParam.push(urlFragment);
      } else {
        const nearestSpreadNode = getNearestAncestorNodeWithSpreadParam(routeFragments);
        if (nearestSpreadNode) {
          const nodeIndex = indexOfNode(routeFragments, nearestSpreadNode);
          const removed = routeFragments.splice(nodeIndex);
          ufIndex = ufIndex - removed.length;
          routeFragments.push(createFragment(nearestSpreadNode, urlFragments[ufIndex], currentSpreadParam));
          currentNode = nearestSpreadNode;
        } else {
          const fallback = currentNode._fallback;
          if (!fallback) {
            throw new Error(`router: "${router.name || "[default]"}" could not find route: ${url2}`);
          } else {
          }
          routeFragments.splice(fallback.level);
          routeFragments.push(new RouteFragment(this, fallback, ""));
          break;
        }
      }
    }
    let lastNode = routeFragments[routeFragments.length - 1].node;
    while (lastNode) {
      lastNode = lastNode.children.find((node2) => node2.name === "index");
      if (lastNode)
        routeFragments.push(new RouteFragment(this, lastNode, ""));
    }
    if (!routeFragments.filter(({ node: node2 }) => node2.module).length)
      throw new Error(`could not find route: ${url2}`);
    return routeFragments;
  }
};

// node_modules/consolite/esm/index.mjs
var defaults = {
  filter: "",
  level: 3,
  levels: {
    default: 3,
    error: 1,
    warn: 2,
    debug: 4,
    trace: 4
  }
};
var noop = (x) => x;
var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
var escapeIfString = (str) => typeof str === "string" ? escapeRegExp(str) : str;
var canBind = (prop) => typeof console[prop] === "function";
var Consolite = class {
  constructor(...prefix) {
    __publicField(this, "prefix", []);
    __publicField(this, "_filter", null);
    __publicField(this, "_level", null);
    __publicField(this, "_levels", {});
    __publicField(this, "parent", null);
    __publicField(this, "levels", new Proxy(this._levels, {
      get: (target, prop) => {
        var _a, _b;
        return target[prop] || target.default || ((_a = this.parent) == null ? void 0 : _a.levels[prop]) || ((_b = this.parent) == null ? void 0 : _b.levels.default) || defaults.levels[prop] || defaults.levels.default;
      },
      set: (target, prop, value) => target[prop] = value
    }));
    __publicField(this, "create", createLogger);
    this.prefix.push(...prefix);
    const withinLevel = (prop) => this.levels[prop] <= this.level;
    const passesFilter = () => typeof this.filter === "function" ? this.filter(prefix) : prefix.join("").match(escapeIfString(this.filter));
    const shouldPrint = (prop) => withinLevel(prop) && passesFilter() && canBind(prop);
    Object.keys(console).forEach((prop) => Object.defineProperty(this, prop, {
      get: () => {
        const prefixes = prefix.map((p) => typeof p === "string" ? p : p(prop, this));
        return shouldPrint(prop) ? console[prop].bind(console, ...prefixes) : noop;
      }
    }));
  }
  get level() {
    var _a, _b, _c;
    return (_c = (_b = this._level) != null ? _b : (_a = this.parent) == null ? void 0 : _a.level) != null ? _c : defaults.level;
  }
  set level(val) {
    this._level = val;
  }
  get filter() {
    var _a, _b, _c;
    return (_c = (_b = this._filter) != null ? _b : (_a = this.parent) == null ? void 0 : _a.filter) != null ? _c : defaults.filter;
  }
  set filter(val) {
    this._filter = val;
  }
  get root() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.root) || this;
  }
  createChild(...prefix) {
    const child = createLogger(...this.prefix, ...prefix);
    child.parent = this;
    return child;
  }
  createParent(...prefix) {
    return createLogger(...prefix, ...this.prefix);
  }
};
var createLogger = (...prefix) => Object.assign(new Consolite(...prefix));

// node_modules/@roxi/routify/lib/runtime/utils/logger.js
var log = createLogger("[rf3]");
var createRootLogger = () => {
  Object.assign(log, loadState());
  return new Proxy(log, {
    get: (target, prop) => target[prop],
    set: (target, prop, value) => {
      target[prop] = value;
      saveState(log);
      return false;
    }
  });
};
var loadState = () => {
  if (typeof window === "undefined") {
    const level = process.env.DEBUG_LEVEL;
    const filter = process.env.DEBUG_FILTER;
    return { level, filter };
  } else {
    return JSON.parse(localStorage.getItem("__routify.logState") || "{}");
  }
};
var saveState = (log2) => {
  const { level, filter } = log2;
  if (typeof window === "undefined") {
    process.env.DEBUG_LEVEL = level;
    process.env.DEBUG_FILTER = filter;
  } else
    localStorage.setItem("__routify.logState", JSON.stringify({ filter, level }));
};
var debugWrapper = (fn, msg) => (...params2) => {
  const result = fn(...params2);
  log.debug(msg, { params: params2, result });
  return result;
};

// node_modules/@roxi/routify/lib/runtime/utils/index.js
var pathAndParamsToUrl = (path, params2 = {}, queryHandler) => {
  Object.entries(params2).forEach(([key, val]) => {
    if (path.includes(`[${key}]`)) {
      path = path.replace(`[${key}]`, val);
      delete params2[key];
    }
  });
  return path + queryHandler(params2);
};
var fromEntries = (iterable) => {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
};
var populateUrl = (path, params2, queryHandler) => {
  const overloads = {};
  Object.entries(params2).forEach(([param, value]) => {
    const RE = new RegExp(`\\[${param}\\]|\\:${param}`);
    if (path.match(RE))
      path = path.replace(`[${param}]`, value);
    else
      overloads[param] = value;
  });
  const query = Object.keys(overloads).length ? queryHandler.stringify(overloads) : "";
  return path + query;
};
var urlFromAddress = () => (({ pathname, search, hash }) => pathname + search + hash)(window.location);
var contexts = {
  get router() {
    return getContext("routify-fragment-context").route.router;
  },
  get fragment() {
    return getContext("routify-fragment-context");
  }
};
var getContextMaybe = (name) => {
  try {
    return getContext(name);
  } catch (err) {
  }
};
var getable = (value, start) => {
  const store = writable(value, start);
  return Object.assign(store, { get: () => get_store_value(store) });
};
var identicalRoutes = (...routes) => routes.map((route) => JSON.stringify([route == null ? void 0 : route.allFragments, route == null ? void 0 : route.url])).reduce((prev, curr) => prev === curr && curr);

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/ReflectorBase.js
var BaseReflector = class {
  constructor(router) {
    this.router = router;
    this.log = this.router.log;
  }
  install() {
  }
  uninstall() {
  }
  reflect() {
  }
};

// node_modules/@roxi/routify/lib/runtime/plugins/scrollHandler/util.js
var sleep = () => new Promise(requestAnimationFrame);
var scrollIsIdle = (timeout = 100) => new Promise((resolve) => {
  let scrollTimeout;
  const listener = async (e) => {
    clearTimeout(scrollTimeout);
    await sleep();
    scrollTimeout = setTimeout(() => {
      resolve();
      removeEventListener("scroll", listener);
    }, timeout);
  };
  addEventListener("scroll", listener);
});

// node_modules/@roxi/routify/lib/runtime/plugins/scrollHandler/scrollHandler.js
var isScrolling = writable(false);
var run = ({ route }, history2) => {
  var _a;
  const [path, hash] = route.url.split("#");
  const [prevPath, _prevHash] = ((_a = history2[0]) == null ? void 0 : _a.url.split("#")) || [];
  if (!hash)
    return;
  const scroll = async (event) => {
    const samePath = path === prevPath;
    const elem = document.getElementById(hash);
    if (elem)
      elem.scrollIntoView({ behavior: samePath ? "smooth" : "auto" });
    if (samePath && elem) {
      isScrolling.set(true);
      await scrollIsIdle();
      isScrolling.set(false);
    }
    if (!samePath && !event) {
      const observer = new MutationObserver(scroll);
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        characterData: true
      });
      setTimeout(observer.disconnect.bind(observer), 500);
    }
  };
  scroll();
};
var scrollHandler = { isScrolling, run };

// node_modules/@roxi/routify/lib/runtime/Global/BrowserAdapter.js
var createBrowserAdapter = (opts) => {
  const delimiter = (opts == null ? void 0 : opts.delimiter) || ";";
  return {
    toRouter: (url2, router) => {
      const formatRE = router.name ? `${router.name}=(.+?)` : `(.+?)`;
      const RE = new RegExp(`(^|${delimiter})${formatRE}(${delimiter}|$)`);
      const matches = url2.match(RE);
      return matches ? matches[2] : "/";
    },
    toBrowser: (routers) => routers.map((r) => (r.name ? `${r.name}=` : "") + r.url.external()).join(delimiter)
  };
};

// node_modules/@roxi/routify/lib/runtime/Global/Global.js
var Global = class {
  constructor() {
    __publicField(this, "instances", []);
    __publicField(this, "browserAdapter", createBrowserAdapter());
    __publicField(this, "urlFromBrowser", (router) => {
      if (debugWrapper)
        return debugWrapper(this.browserAdapter.toRouter, "calling browserAdapter.toRouter")(urlFromAddress(), router);
      return this.browserAdapter.toRouter(urlFromAddress(), router);
    });
    if (typeof window !== "undefined")
      window["__routify"] = this;
    this.log = createRootLogger();
  }
  get routers() {
    return [].concat(...this.instances.map((instance) => instance.routers));
  }
  register(instance) {
    this.instances.push(instance);
    return this;
  }
};
var globalInstance = new Global();

// node_modules/@roxi/routify/lib/runtime/Instance/UrlParamUtils.js
var defaultRe = /\[(.+?)\]/gm;
var UrlParamUtils = class {
  constructor(RE = defaultRe) {
    __publicField(this, "getFieldsFromName", (name) => [...name.matchAll(this.RE)].map((v) => v[1]));
    __publicField(this, "getRegexFromName", (name) => new RegExp("^" + name.replace(this.RE, "(.+)") + "$"));
    __publicField(this, "getValuesFromPath", (re, path) => (path.match(re) || []).slice(1));
    __publicField(this, "mapFieldsWithValues", (fields, values) => this.haveEqualLength(fields, values) && fields.reduce((map, field, index) => {
      map[field] = values[index];
      return map;
    }, {}));
    __publicField(this, "haveEqualLength", (fields, values) => {
      if (fields.length !== values.length)
        throw new Error(`fields and values should be of same length
fields: ${JSON.stringify(fields)}
values: ${JSON.stringify(values)}`);
      return true;
    });
    this.RE = RE;
  }
};

// node_modules/@roxi/routify/lib/common/RNode.js
var RNode = class {
  constructor(name, module, instance) {
    __publicField(this, "instance");
    __publicField(this, "parent");
    __publicField(this, "meta", {});
    __publicField(this, "id");
    this.instance = instance;
    this.name = name;
    instance.nodeIndex.push(this);
    this.module = module;
    Object.defineProperty(this, "Instance", { enumerable: false });
    Object.defineProperty(this, "instance", { enumerable: false });
    Object.defineProperty(this, "parent", { enumerable: false });
  }
  appendChild(child) {
    child.parent = this;
  }
  createChild(name, module) {
    const node2 = this.instance.createNode(name, module);
    this.appendChild(node2);
    return node2;
  }
  get descendants() {
    return this.instance.nodeIndex.filter((node2) => node2.ancestors.find((n) => n === this));
  }
  remove() {
    const { nodeIndex } = this.instance;
    const index = nodeIndex.findIndex((node2) => node2 === this);
    nodeIndex.splice(index, 1);
  }
  get ancestors() {
    let node2 = this;
    const ancestors = [];
    while (node2 = node2.parent)
      ancestors.push(node2);
    return ancestors;
  }
  get root() {
    let node2 = this;
    while (node2.parent)
      node2 = node2.parent;
    return node2;
  }
  get isRoot() {
    return this === this.root;
  }
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this);
  }
  get level() {
    var _a;
    return (((_a = this.parent) == null ? void 0 : _a.level) || 0) + 1;
  }
  traverse(path) {
    const originNode = path.startsWith("/") ? this.root : this;
    const steps = path.split("/").filter((snip) => snip !== ".").filter(Boolean);
    try {
      const target = steps.reduce((target2, step) => step === ".." ? target2.parent : target2.children.find((node2) => node2.name === step), originNode);
      return target;
    } catch (err) {
      console.error("can't resolve path", path, "from", this.path, "\n", err);
    }
  }
  toJSON() {
    return __spreadProps(__spreadValues({}, this), {
      children: [...this.children]
    });
  }
  get path() {
    return "/" + [this, ...this.ancestors].reverse().map((node2) => node2.name).filter(Boolean).join("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/RNodeRuntime.js
import Node from "/Users/def/Documents/GitHub/stealth_api/node_modules/@roxi/routify/lib/runtime/Instance/Node.svelte";
var _regex;
var RNodeRuntime = class extends RNode {
  constructor() {
    super(...arguments);
    __privateAdd(this, _regex, {});
    __publicField(this, "importTree", (snapshotRoot) => {
      const queue = [[this, snapshotRoot]];
      while (queue.length) {
        const [node2, snapshot] = queue.pop();
        const _a = snapshot, { children } = _a, nodeSnapshot = __objRest(_a, ["children"]);
        Object.assign(node2, nodeSnapshot);
        for (const childSnapshot of children) {
          const childNode = node2.createChild(snapshot.name || snapshot.rootName || "");
          queue.push([childNode, childSnapshot]);
        }
      }
      return this;
    });
  }
  get regex() {
    const { name } = this;
    if (!__privateGet(this, _regex)[name])
      __privateGet(this, _regex)[name] = this.instance.utils.getRegexFromName(this.name);
    return __privateGet(this, _regex)[name];
  }
  set regex(value) {
    __privateGet(this, _regex)[this.name] = new RegExp(value);
  }
  get children() {
    const nodes = this.instance.nodeIndex;
    return nodes.filter((node2) => node2.parent === this).sort((prev, curr) => (prev.meta.order || 0) - (curr.meta.order || 0));
  }
  get pages() {
    return this.children.filter((node2) => node2.name !== "index").filter((node2) => !node2.meta.fallback).filter((node2) => !node2.name.startsWith("_")).filter((node2) => !node2.name.includes("[")).filter((node2) => {
      var _a;
      return !(((_a = node2.meta) == null ? void 0 : _a.order) === false);
    });
  }
  getRawComponent() {
    return this.module && new Promise((resolve) => {
      const modulePromise = this.module();
      const rawComponent = modulePromise.then ? modulePromise.then((r) => r.default) : modulePromise.default;
      resolve(rawComponent);
    });
  }
  get component() {
    const node2 = this;
    return function(options) {
      options.props = __spreadProps(__spreadValues({}, options.props), {
        passthrough: options.props,
        node: node2
      });
      return new Node(__spreadValues({}, options));
    };
  }
  appendChild(child) {
    if (child.instance)
      child.parent = this;
  }
  get _fallback() {
    var _a;
    return this.children.find((node2) => node2.meta.fallback) || ((_a = this.parent) == null ? void 0 : _a._fallback);
  }
};
_regex = new WeakMap();

// node_modules/@roxi/routify/lib/common/Routify.js
var Routify = class {
  constructor(options) {
    __publicField(this, "Node", RNode);
    __publicField(this, "mode", "runtime");
    __publicField(this, "nodeIndex", []);
    __publicField(this, "rootNodes", {});
  }
  createNode(name, module) {
    return new this.Node(name, module, this);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/RoutifyRuntime.js
var RoutifyRuntime = class extends Routify {
  constructor(options) {
    super();
    __publicField(this, "Node", RNodeRuntime);
    __publicField(this, "mode", "runtime");
    __publicField(this, "routers", []);
    __publicField(this, "rootNodes", {});
    this.options = options;
    if (options.routes) {
      this.rootNodes[options.routes.rootName || "unnamed"] = this.createNode(options.routes.rootName).importTree(options.routes);
    }
    this.utils = new UrlParamUtils();
    this.global = globalInstance.register(this);
    Object.defineProperty(this, "routers", { enumerable: false });
    this.log = this.global.log;
  }
};

// node_modules/hookar/index.js
var createHooksCollection = (runner) => {
  const hooks = [];
  const hooksCollection = (hook) => {
    hooks.push(hook);
    return () => hooks.splice(hooks.indexOf(hook), 1);
  };
  hooksCollection.hooks = hooks;
  hooksCollection.run = runner(hooks);
  return hooksCollection;
};
var createPipelineCollection = (type) => createHooksCollection((hooks) => (value, ...rest) => hooks.reduce((pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => hook(r, ...rest)) : hook(pipedValue, ...rest), value));
var createSequenceHooksCollection = (type) => createHooksCollection((hooks) => (value, ...rest) => hooks.reduce((last, hook) => (last == null ? void 0 : last.then) ? last.then((_) => hook(value, ...rest)) : hook(value, ...rest), value));
var createGuardsCollection = (type) => createHooksCollection((hooks) => (value, ...rest) => hooks.reduce((pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => r && hook(r, ...rest)) : pipedValue && hook(pipedValue, ...rest), value || true));

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Address.js
var AddressReflector = class extends BaseReflector {
  constructor(router) {
    super(router);
    __publicField(this, "reflect", () => {
      const { mode } = get_store_value(this.router.activeRoute);
      if (mode === "popState")
        return false;
      const { routers, browserAdapter } = this.router.instance.global;
      const addressRouters = routers.filter((router) => router.urlReflector instanceof this.constructor);
      const url2 = browserAdapter.toBrowser(addressRouters);
      this.log.debug("pushing internal url to browser", {
        mode,
        url: url2,
        currentBrowserUrl: urlFromAddress(),
        currentInternalUrl: this.router.url.internal()
      });
      history[`${mode}Native`]({}, "", url2);
    });
    const { instance, urlRewrites } = router;
    const { urlFromBrowser, browserAdapter } = instance.global;
    if (!history["onPushstate"]) {
      this.log.debug("polyfill history hooks");
      polyfillHistory();
    }
    const createStateEventHandler = (method) => {
      return function(data, title, url2) {
        var _a, _b;
        const routerName = (_b = (_a = data == null ? void 0 : data.routify) == null ? void 0 : _a.router) != null ? _b : false;
        if (routerName === false)
          url2 = browserAdapter.toRouter(url2, router);
        else if (routerName !== router.name)
          return false;
        for (const rewrite of urlRewrites)
          url2 = rewrite.toInternal(url2, { router });
        router.url[method](url2);
      };
    };
    this.absorb = () => router.url.replace(urlFromBrowser(router));
    this._pushstateHandler = createStateEventHandler("push");
    this._replacestateHandler = createStateEventHandler("replace");
    this._popstateHandler = () => router.url.pop(urlFromBrowser(router));
  }
  install() {
    this.hooks = [
      history["onPushstate"](this._pushstateHandler),
      history["onReplacestate"](this._replacestateHandler),
      history["onPopstate"](this._popstateHandler)
    ];
    if (!get_store_value(this.router.activeRoute))
      this.absorb();
    else
      this.reflect();
  }
  uninstall() {
    this.hooks.forEach((unreg) => unreg());
    setTimeout(() => this.reflect());
  }
};
function polyfillHistory() {
  const hooks = {
    onPushstate: createSequenceHooksCollection(),
    onReplacestate: createSequenceHooksCollection(),
    onPopstate: createSequenceHooksCollection()
  };
  Object.assign(history, hooks);
  const { pushState, replaceState } = history;
  history["pushStateNative"] = pushState;
  history["replaceStateNative"] = replaceState;
  history.pushState = hooks.onPushstate.run;
  history.replaceState = hooks.onReplacestate.run;
  window.addEventListener("popstate", hooks.onPopstate.run);
  return true;
}

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Internal.js
var InternalReflector = class extends BaseReflector {
};

// node_modules/@roxi/routify/lib/runtime/Router/Router.js
var _urlReflector;
var _Router = class {
  constructor(options) {
    __publicField(this, "subscribe");
    __publicField(this, "set", (x) => x);
    __publicField(this, "pendingRoute", getable(null));
    __publicField(this, "activeRoute", getable(null));
    __privateAdd(this, _urlReflector, null);
    __publicField(this, "urlRewrites", []);
    __publicField(this, "beforeUrlChange", createGuardsCollection());
    __publicField(this, "afterUrlChange", createSequenceHooksCollection());
    __publicField(this, "beforeRender", createPipelineCollection());
    __publicField(this, "onDestroy", createSequenceHooksCollection());
    __publicField(this, "parentElem", null);
    __publicField(this, "queryHandler", {
      parse: (search) => fromEntries(new URLSearchParams(search)),
      stringify: (params2) => "?" + new URLSearchParams(params2).toString()
    });
    __publicField(this, "scrollHandler", scrollHandler);
    __publicField(this, "url", {
      internal: () => this.url.getPending() || this.url.getActive(),
      external: () => this.getExternalUrl(),
      getActive: () => {
        var _a;
        return (_a = get_store_value(this.activeRoute)) == null ? void 0 : _a.url;
      },
      getPending: () => {
        var _a;
        return (_a = get_store_value(this.pendingRoute)) == null ? void 0 : _a.url;
      },
      toString: () => this.url.internal(),
      set: this._setUrl,
      push: (url2) => this._setUrl(url2, "pushState"),
      replace: (url2) => this._setUrl(url2, "replaceState"),
      pop: (url2) => this._setUrl(url2, "popState")
    });
    __publicField(this, "ready", (() => new Promise((resolve) => {
      let unsub;
      unsub = this.activeRoute.subscribe((route) => {
        if (route)
          resolve();
        if (unsub)
          unsub();
      });
    }))());
    __publicField(this, "history", []);
    __publicField(this, "setParentElem", (elem) => this.parentElem = elem);
    __publicField(this, "getExternalUrl", (url2) => this.urlRewrites.reduce((_url, rewrite) => rewrite.toExternal(_url, { router: this }), url2 || this.url.internal()));
    __publicField(this, "getInternalUrl", (url2) => this.urlRewrites.reduce((_url, rewrite) => rewrite.toInternal(_url, { router: this }), url2));
    Object.assign(this, writable(this));
    this.init(options);
    this.params = derived(this.activeRoute, ($activeRoute) => $activeRoute.params);
    this.afterUrlChange(() => {
      setTimeout(() => __privateGet(this, _urlReflector).reflect());
    });
    this.afterUrlChange(this.scrollHandler.run);
    this.activeRoute.get = () => get_store_value(this.activeRoute);
    this.pendingRoute.get = () => get_store_value(this.pendingRoute);
  }
  init({
    instance,
    rootNode,
    name,
    routes,
    urlRewrite,
    urlReflector,
    url: url2,
    passthrough,
    beforeUrlChange,
    afterUrlChange,
    beforeRender
  } = {}) {
    const parentCmpCtx = getContextMaybe("routify-fragment-context");
    this.instance = instance || this.instance || (parentCmpCtx == null ? void 0 : parentCmpCtx.route.router.instance) || globalInstance.instances[0] || new RoutifyRuntime({});
    this.name = name || this.name || "";
    this.log = this.log || this.instance.log.createChild(this.name || "[unnamed instance]");
    this.urlRewrites = [urlRewrite].flat().filter(Boolean);
    if (passthrough && !(passthrough instanceof _Router))
      passthrough = (parentCmpCtx == null ? void 0 : parentCmpCtx.route.router) || passthrough;
    this.passthrough = passthrough || this.passthrough;
    globalInstance.instances.forEach((inst) => {
      const index = inst.routers.indexOf(this);
      if (index !== -1)
        inst.routers.splice(index, 1);
    });
    if (beforeUrlChange)
      this.beforeUrlChange(beforeUrlChange);
    if (afterUrlChange)
      this.afterUrlChange(afterUrlChange);
    if (beforeRender)
      this.beforeRender(beforeRender);
    this.instance.routers.push(this);
    if (routes)
      this.importRoutes(routes);
    this.parentCmpCtx = parentCmpCtx;
    this.rootNode = rootNode || this.rootNode || this.instance.rootNodes.default;
    this.log.debug("initiated router");
    this.set(this);
    if (this.url.getActive()) {
      this.log.debug("router was created with activeUrl");
      this._setUrl(this.url.getActive(), "pushState", true);
    }
    if (!this.urlReflector) {
      urlReflector = urlReflector || (typeof window != "undefined" ? AddressReflector : InternalReflector);
      this.setUrlReflector(urlReflector);
    }
    if (url2)
      this.url.replace(url2);
  }
  importRoutes(routes) {
    this.rootNode = this.instance.createNode().importTree(routes);
    this.instance.rootNodes[routes.rootName || "unnamed"] = this.rootNode;
  }
  async _setUrl(url2, mode, isInternal) {
    if (!isInternal)
      url2 = this.getInternalUrl(url2);
    url2 = url2 || "/";
    url2 = url2.replace(/(.+)\/+([#?]|$)/, "$1$2");
    const { activeRoute: activeRoute2, pendingRoute: pendingRoute2 } = this;
    const $activeRoute = activeRoute2.get();
    const { debug, groupCollapsed, trace, groupEnd } = this.log;
    if (this.log.level >= 4) {
      const info = {
        url: url2,
        mode,
        prev: this.url.internal(),
        browserOld: urlFromAddress()
      };
      [groupCollapsed("set url", info), trace(), groupEnd()];
    }
    if (!url2.startsWith("/"))
      url2 = url2.replace(new URL(url2).origin, "");
    const route = new Route(this, url2, mode);
    const currentRoute = pendingRoute2.get() || activeRoute2.get();
    if (identicalRoutes(currentRoute, route)) {
      debug("current route is identical - skip", currentRoute, route);
      return true;
    }
    route.log.debug("set pending route", route);
    pendingRoute2.set(route);
    await route.loadRoute();
    return true;
  }
  destroy() {
    this.log.debug(`destroying router`);
    this.instance.routers = this.instance.routers.filter((router) => router !== this);
    this.onDestroy.run({ router: this });
  }
  get urlReflector() {
    return __privateGet(this, _urlReflector);
  }
  setUrlReflector(UrlReflector) {
    var _a;
    (_a = __privateGet(this, _urlReflector)) == null ? void 0 : _a.uninstall();
    __privateSet(this, _urlReflector, new UrlReflector(this));
    __privateGet(this, _urlReflector).install();
  }
};
var Router = _Router;
_urlReflector = new WeakMap();
var createRouter = (options) => new Router(options);

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/LocalStorage.js
var LocalStorageReflector = class extends BaseReflector {
  constructor(router) {
    super(router);
    this.storageName = `__routify-router-${this.router.name}`;
  }
  reflect() {
    window.localStorage.setItem(this.storageName, this.router.url.internal());
  }
};

// node_modules/@roxi/routify/lib/runtime/index.js
import Component from "/Users/def/Documents/GitHub/stealth_api/node_modules/@roxi/routify/lib/runtime/Router/Component.svelte";

// node_modules/@roxi/routify/lib/runtime/helpers/index.js
var getMRCA = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  return lineage1.find((node3) => lineage2.includes(node3));
};
var getPath = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  const mrca = getMRCA(node1, node2);
  const backtrackSteps = lineage1.indexOf(mrca);
  const backtrackStr = backtrackSteps ? "../".repeat(backtrackSteps) : "";
  const forwardSteps = lineage2.indexOf(mrca);
  const forwardStepsStr = lineage2.slice(0, forwardSteps).reverse().map((n) => n.name).join("/");
  return backtrackStr + forwardStepsStr;
};
var goto = {
  subscribe: (run2, invalidate) => {
    const { router } = contexts;
    return derived(url, ($url) => (path, userParams, options) => {
      const newUrl = $url(path, userParams);
      router.url.push(newUrl);
    }).subscribe(run2, invalidate);
  }
};
var url = {
  subscribe: (run2, invalidate) => {
    const { router } = contexts;
    let originNode = contexts.fragment.node;
    return derived(router.activeRoute, (activeRoute2) => {
      originNode = router.rootNode.traverse(originNode.path);
      return (inputPath, userParams = {}) => {
        const offset = inputPath.startsWith("/") ? router.rootNode.path : "";
        const targetNode = originNode.traverse(offset + inputPath);
        if (!targetNode) {
          console.error("could not find destination node", inputPath);
          return;
        }
        const mrca = getMRCA(targetNode, router.rootNode);
        const path = "/" + getPath(mrca, targetNode);
        const params2 = __spreadValues(__spreadValues({}, inheritedParams(targetNode, activeRoute2)), userParams);
        const internalUrl = populateUrl(path, params2, router.queryHandler);
        return router.getExternalUrl(internalUrl);
      };
    }).subscribe(run2, invalidate);
  }
};
var inheritedParams = (node2, route) => {
  const lineage = [node2, ...node2.ancestors].reverse();
  const params2 = lineage.map((_node) => {
    var _a;
    return (_a = route.fragments.find((fragment) => fragment.node === _node || fragment.node.path === _node.path)) == null ? void 0 : _a.params;
  });
  return Object.assign({}, ...params2);
};
var params = {
  subscribe: (run2, invalidate) => derived(contexts.router.params, (params2) => params2).subscribe(run2, invalidate)
};
var isActive = {
  subscribe: (run2, invalidate) => derived(contexts.router.activeRoute, isActiveRoute).subscribe(run2, invalidate)
};
var isActiveRoute = ($route) => isActiveUrl($route.url);
var isActiveUrl = (url2) => (path, params2, options = {}) => {
  const { recursive } = __spreadValues({ recursive: true }, options);
  path = pathAndParamsToUrl(path, params2, (x) => "");
  if (recursive)
    path = path.replace(/\/index\/?$/, "");
  return (url2 + "/").startsWith(path + "/");
};
var resolveNode = (path) => {
  const { node: node2 } = contexts.fragment;
  return path.startsWith("/") ? resolveAbsoluteNode(node2, path) : path.startsWith(".") ? traverseNode(node2, path) : resolveNamedNode(node2, path);
};
var resolveAbsoluteNode = (node2, path) => {
};
var traverseNode = (node2, path) => node2.traverse(path);
var resolveNamedNode = (node2, name) => {
};
var pseudoStore = (ret) => ({
  subscribe: (run2) => {
    run2(ret());
    return () => {
    };
  }
});
var context = pseudoStore(() => contexts.fragment);
var node = pseudoStore(() => get_store_value(context).node);
var meta = pseudoStore(() => get_store_value(node).meta);
var activeRoute = {
  subscribe: (run2) => contexts.router.activeRoute.subscribe(run2)
};
var pendingRoute = {
  subscribe: (run2) => contexts.router.pendingRoute.subscribe(run2)
};

// node_modules/@roxi/routify/lib/common/helpers.js
var gentleAssign = (target, ...sources) => {
  sources.forEach((source) => Object.keys(source).forEach((key) => {
    var _a;
    return target[key] = (_a = target[key]) != null ? _a : source[key];
  }));
  return target;
};
var assignNode = (target, ...sources) => {
  gentleAssign(target, ...sources);
  gentleAssign(target.meta, ...sources.map((s) => s.meta));
  sources.forEach((source) => {
    source.children.forEach((sNode) => {
      let tNode = target.children.find((tNode2) => tNode2.name === sNode.name);
      if (!tNode)
        tNode = target.createChild(null, null);
      assignNode(tNode, sNode);
    });
  });
  return target;
};

// node_modules/@roxi/routify/lib/runtime/index.js
var Routify2 = RoutifyRuntime;
export {
  AddressReflector,
  Component,
  InternalReflector,
  LocalStorageReflector,
  Router2 as Router,
  Router as RouterClass,
  Routify2 as Routify,
  activeRoute,
  assignNode,
  context,
  createRouter,
  getMRCA,
  getPath,
  globalInstance,
  goto,
  isActive,
  isActiveRoute,
  isActiveUrl,
  meta,
  node,
  params,
  pendingRoute,
  resolveAbsoluteNode,
  resolveNamedNode,
  resolveNode,
  traverseNode,
  url
};
//# sourceMappingURL=@roxi_routify.js.map
