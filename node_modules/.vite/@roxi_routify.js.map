{
  "version": 3,
  "sources": ["../@roxi/routify/lib/runtime/index.js", "../@roxi/routify/lib/runtime/Route/RouteFragment.js", "../@roxi/routify/lib/runtime/Route/utils.js", "../@roxi/routify/lib/runtime/Route/Route.js", "../consolite/esm/index.mjs", "../@roxi/routify/lib/runtime/utils/logger.js", "../@roxi/routify/lib/runtime/utils/index.js", "../@roxi/routify/lib/runtime/Router/urlReflectors/ReflectorBase.js", "../@roxi/routify/lib/runtime/plugins/scrollHandler/util.js", "../@roxi/routify/lib/runtime/plugins/scrollHandler/scrollHandler.js", "../@roxi/routify/lib/runtime/Global/BrowserAdapter.js", "../@roxi/routify/lib/runtime/Global/Global.js", "../@roxi/routify/lib/runtime/Instance/UrlParamUtils.js", "../@roxi/routify/lib/common/RNode.js", "../@roxi/routify/lib/runtime/Instance/RNodeRuntime.js", "../@roxi/routify/lib/common/Routify.js", "../@roxi/routify/lib/runtime/Instance/RoutifyRuntime.js", "../hookar/index.js", "../@roxi/routify/lib/runtime/Router/urlReflectors/Address.js", "../@roxi/routify/lib/runtime/Router/urlReflectors/Internal.js", "../@roxi/routify/lib/runtime/Router/Router.js", "../@roxi/routify/lib/runtime/Router/urlReflectors/LocalStorage.js", "../@roxi/routify/lib/runtime/helpers/index.js", "../@roxi/routify/lib/common/helpers.js"],
  "sourcesContent": ["// @ts-ignore\nimport Router from './Router/Router.svelte'\nimport { createRouter, Router as RouterClass } from './Router/Router.js'\nimport { RoutifyRuntime } from './Instance/RoutifyRuntime.js'\n\nimport { globalInstance } from './Global/Global.js'\nimport { AddressReflector } from './Router/urlReflectors/Address.js'\nimport { LocalStorageReflector } from './Router/urlReflectors/LocalStorage.js'\nimport { InternalReflector } from './Router/urlReflectors/Internal.js'\nimport Component from './Router/Component.svelte'\n\nexport const Routify = RoutifyRuntime\n\nexport {\n    createRouter,\n    Router,\n    RouterClass,\n    globalInstance,\n    AddressReflector,\n    LocalStorageReflector,\n    InternalReflector,\n    Component,\n}\n\nexport * from './helpers/index.js'\nexport * from '../common/helpers.js'\n", "export class RouteFragment {\n    /**\n     * @param {Route} route the route this fragment belongs to\n     * @param {RNodeRuntime} node the node that corresponds to the fragment\n     * @param {String} urlFragment a fragment of the url (fragments = url.split('/'))\n     */\n    constructor(route, node, urlFragment) {\n        this.route = route\n        this.node = node\n        this.load = undefined\n        this.urlFragment = urlFragment\n\n        Object.defineProperty(this, 'route', { enumerable: false })\n    }\n\n    /** @type {Object.<string, string|string[]>} */\n    #params = {}\n\n    get params() {\n        return this.#params\n    }\n\n    setParams(params) {\n        this.#params = params\n    }\n\n    getParamsFromFragment() {\n        const { getFieldsFromName, getValuesFromPath, mapFieldsWithValues } =\n            this.route.router.instance.utils\n\n        return mapFieldsWithValues(\n            getFieldsFromName(this.node.name),\n            getValuesFromPath(this.node.regex, this.urlFragment),\n        )\n    }\n}\n", "const RE = /\\[(.+?)\\]/gm\n\nconst createUrlParamUtils = () => {\n    /**\n     * returns [\"slug\", \"id\"] from \"my[slug]and[id]\"\n     * @param {string} name\n     * @returns {string[]}\n     */\n    const getFieldsFromName = name => [...name.matchAll(RE)].map(v => v[1])\n\n    /**\n     * converts \"my[slug]and[id]\" to /my(.+)and(.+)/gm\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    const getRegexFromName = name => new RegExp(name.replace(RE, '(.+)'))\n\n    /**\n     * returns an array of values matching a regular expresion and path\n     * @param {RegExp} re\n     * @param {string} path\n     * @returns {string[]}\n     */\n    const getValuesFromPath = (re, path) => (path.match(re) || []).slice(1)\n\n    /**\n     * converts (['a', 'b', 'c'], [1, 2, 3]) to {a: 1, b: 2, c: 3}\n     * @param {string[]} fields\n     * @param {string[]} values\n     * @returns\n     */\n    const mapFieldsWithValues = (fields, values) =>\n        haveEqualLength(fields, values) &&\n        fields.reduce((map, field, index) => {\n            map[field] = values[index]\n            return map\n        }, {})\n\n    const haveEqualLength = (fields, values) => {\n        if (fields.length !== values.length)\n            throw new Error(\n                'fields and values should be of same length' +\n                    `\\nfields: ${JSON.stringify(fields)}` +\n                    `\\nvalues: ${JSON.stringify(values)}`,\n            )\n        return true\n    }\n\n    return {\n        getFieldsFromName,\n        getRegexFromName,\n        getValuesFromPath,\n        mapFieldsWithValues,\n        haveEqualLength,\n    }\n}\n\nconst spreadsLast = node => (node.name.match(/\\[\\.\\.\\.(.+)\\]/) ? 1 : -1)\n\n/**\n *\n * @param {RouteFragment[]} routeFragments\n * @returns {RNodeRuntime}\n */\nconst getNearestAncestorNodeWithSpreadParam = routeFragments => {\n    for (const fragment of [...routeFragments].reverse()) {\n        for (const node of fragment.node.parent?.children || []) {\n            const match = node.name.match(/\\[\\.\\.\\.(.+)\\]/)\n            if (match) return node\n        }\n    }\n}\n\nconst getUrlFragments = url =>\n    url\n        .replace(/[?#].+/, '') // strip the search and hash query\n        .replace(/\\/$/, '') // strip trailing slash\n        .split('/')\n        .slice(1) // skip the first fragment since it will always be empty\n\nconst indexOfNode = (fragments, node) =>\n    fragments.findIndex(fragment => fragment.node === node)\n\nexport {\n    spreadsLast,\n    getNearestAncestorNodeWithSpreadParam,\n    getUrlFragments,\n    indexOfNode,\n}\n", "import { get } from 'svelte/store'\nimport { RouteFragment } from './RouteFragment.js'\nimport {\n    getNearestAncestorNodeWithSpreadParam,\n    getUrlFragments,\n    indexOfNode,\n    spreadsLast,\n} from './utils.js'\nimport * as msgs from '../../common/debugMsg.js'\n\n/** @type {UrlState[]} */\nconst URL_STATES = ['pushState', 'replaceState', 'popState']\n\nexport class Route {\n    /** @type {RouteFragment[]} */\n    allFragments = []\n    /** @type {RouteFragment[]} only fragments with components */\n    get fragments() {\n        return this.allFragments.filter(f => f.node.module)\n    }\n\n    /** @type {Promise<{route: Route}>} */\n    loaded\n\n    invalid = null\n\n    /**\n     * @param {Router} router\n     * @param {string} url\n     * @param {UrlState} mode\n     */\n    constructor(router, url, mode) {\n        this.router = router\n        this.url = url\n        this.mode = mode\n\n        if (!router.rootNode) {\n            this.router.log.error(\"Can't navigate without a rootNode\")\n            const err = new Error(\"Can't navigate without a rootNode\")\n            Object.assign(err, { routify: { router } })\n            throw err\n        }\n\n        if (!URL_STATES.includes(mode))\n            throw new Error('url.mode must be pushState, replaceState or popState')\n\n        this.allFragments = this._createFragments()\n        this.log = router.log.createChild('[route]') // ROUTIFY-DEV-ONLY\n        this.log.debug('created', this) // ROUTIFY-DEV-ONLY\n    }\n\n    get params() {\n        const match = this.url.match(/\\?.+/)\n        const query = match && match[0]\n\n        return Object.assign(\n            {},\n            ...this.allFragments.map(fragment => fragment.params),\n            query && this.router.queryHandler.parse(query),\n        )\n    }\n\n    async loadRoute() {\n        const { router } = this\n        const pipeline = [\n            this.runBeforeUrlChangeHooks,\n            this.loadComponents,\n            this.runGuards,\n            this.runPreloads,\n        ]\n\n        this.loaded = new Promise(async (resolve, reject) => {\n            for (const pretask of pipeline) {\n                const passedPreTask = await pretask.bind(this)()\n                const routerHasNewerPendingRoute = this !== router.pendingRoute.get()\n                if (routerHasNewerPendingRoute) {\n                    router.pendingRoute.get().loaded.then(resolve).catch(reject)\n                } else if (!passedPreTask) {\n                    router.pendingRoute.set(null)\n                    reject('pretask failed')\n                }\n                if (!passedPreTask || routerHasNewerPendingRoute) return\n            }\n\n            // the route made it through all pretasks, lets set it to active\n            this.router.log.debug('set active route', this) // ROUTIFY-DEV-ONLY\n\n            const $activeRoute = this.router.activeRoute.get()\n            if ($activeRoute) router.history.push($activeRoute)\n\n            router.activeRoute.set(this)\n            const _history = [...router.history].reverse()\n\n            router.afterUrlChange.run({ route: this }, _history)\n\n            this.router.log.debug('unset pending route', this) // ROUTIFY-DEV-ONLY\n            router.pendingRoute.set(null)\n            resolve({ route: this })\n        })\n        return this.loaded\n    }\n\n    /**\n     * converts async module functions to sync functions\n     */\n    async loadComponents() {\n        this.log.debug('load components', this) // ROUTIFY-DEV-ONLY\n        await Promise.all(\n            this.fragments.map(async fragment => {\n                const module = await fragment.node.module()\n                fragment.node.module = () => module\n            }),\n        )\n        return true\n    }\n\n    async runPreloads() {\n        this.log.debug('run preloads', this) // ROUTIFY-DEV-ONLY\n\n        /** @type { RoutifyLoadContext } */\n        const ctx = {\n            route: this,\n            node: [...this.fragments].pop().node,\n        }\n        const promises = this.fragments\n            .filter(fragment => fragment.node.module()?.load)\n            .map(\n                async fragment =>\n                    (fragment.load = await fragment.node.module().load(ctx)),\n            )\n\n        await Promise.all(promises)\n        return true\n    }\n\n    async runGuards() {\n        this.log.debug(`running guards for ${this.url}`, this) // ROUTIFY-DEV-ONLY\n\n        const components = this.fragments\n            .map(fragment => fragment.node.module())\n            .filter(module => module?.guard)\n        // process each component's guard\n        for (const module of components) {\n            const result = await module.guard(this)\n            // if we're not getting a truthy response or the route has been invalidated, return false\n            if (!result || this.invalid) return false\n        }\n        return true\n    }\n\n    async runBeforeUrlChangeHooks() {\n        return await this.router.beforeUrlChange.run({ route: this })\n    }\n\n    /**\n     * creates fragments. A fragment is the section between each / in the URL\n     */\n    _createFragments() {\n        const { url = '', router } = this\n        const { rootNode } = router\n\n        /** @type {string[]} */\n        let currentSpreadParam = []\n        let currentNode = rootNode\n\n        const createFragment = (node, urlFragment, spreadParam) => {\n            const fragment = new RouteFragment(this, node, urlFragment)\n            const spreadMatch = node.name.match(/\\[\\.\\.\\.(.+)\\]/)\n            if (spreadMatch) spreadParam.push(urlFragment)\n            else spreadParam = []\n            if (spreadMatch) fragment.setParams({ [spreadMatch[1]]: spreadParam })\n            else fragment.setParams(fragment.getParamsFromFragment()) //todo create setParamsFromFragment function\n            return fragment\n        }\n\n        const urlFragments = getUrlFragments(url)\n        const routeFragments = [new RouteFragment(this, currentNode, '')]\n\n        // iterate through each url fragment (eg.: 'blog', 'posts', 'some-slug', 'comments')\n        for (let ufIndex = 0; ufIndex < urlFragments.length; ufIndex++) {\n            const urlFragment = urlFragments[ufIndex]\n            const children = currentNode.children.filter(\n                child => !child.name.startsWith('_'),\n            )\n\n            const child =\n                children.find(child => child.name === urlFragment) ||\n                children.sort(spreadsLast).find(child => child.regex.test(urlFragment))\n\n            if (child) {\n                routeFragments.push(\n                    createFragment(child, urlFragment, currentSpreadParam),\n                )\n                currentNode = child\n            } else if (currentSpreadParam.length) {\n                // if currentSpreadParam isn't empty we're part of a spread parameter\n                // and our urlFragment is a parameter value\n                currentSpreadParam.push(urlFragment)\n            } else {\n                // if no child node matches the fragment\n                // and we're not descended from a node with spread operator param\n                // check if there's a spread operator node we can use further down the tree\n                const nearestSpreadNode =\n                    getNearestAncestorNodeWithSpreadParam(routeFragments)\n                if (nearestSpreadNode) {\n                    const nodeIndex = indexOfNode(routeFragments, nearestSpreadNode)\n\n                    const removed = routeFragments.splice(nodeIndex)\n                    ufIndex = ufIndex - removed.length\n                    routeFragments.push(\n                        createFragment(\n                            nearestSpreadNode,\n                            urlFragments[ufIndex],\n                            currentSpreadParam,\n                        ),\n                    )\n\n                    currentNode = nearestSpreadNode\n                } else {\n                    // if there's no spread operator parameter further down the tree\n                    // return the fallback component\n                    const fallback = currentNode._fallback\n\n                    if (!fallback) {\n                        throw new Error(\n                            `router: \"${\n                                router.name || '[default]'\n                            }\" could not find route: ${url}`,\n                        )\n                    } else {\n                    }\n                    routeFragments.splice(fallback.level)\n                    routeFragments.push(new RouteFragment(this, fallback, ''))\n                    break\n                }\n            }\n        }\n\n        let lastNode = routeFragments[routeFragments.length - 1].node\n        while (lastNode) {\n            lastNode = lastNode.children.find(node => node.name === 'index')\n            if (lastNode) routeFragments.push(new RouteFragment(this, lastNode, ''))\n        }\n\n        if (!routeFragments.filter(({ node }) => node.module).length)\n            throw new Error(`could not find route: ${url}`)\n\n        return routeFragments\n    }\n}\n", "/**\n * @callback Filter\n * @param {string[]} prefixes\n */\n\n/**\n * @typedef {Object} Logger\n * @prop {createLogger} create Creates new logger.\n * @prop {createLogger} createChild Creates a child logger. Prefix will be inherited. Level and levels will be inherited if undefined.\n * @prop {createLogger} createParent Creates a parent logger. Prefix will be inherited. Level and levels will be inherited if undefined.\n * @prop {Object.<string, number>} levels\n * @prop {number} level\n * @prop {Filter|string|RegExp} filter\n * @prop {Logger} root\n * @prop {Logger} parent\n */\n\nconst defaults = {\n  filter: '',\n  level: 3,\n  levels: {\n    default: 3,\n    error: 1,\n    warn: 2,\n    debug: 4,\n    trace: 4,\n  },\n}\n\nconst noop = x => x\n\n// $& means the whole matched string\nconst escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\nconst escapeIfString = str => (typeof str === 'string' ? escapeRegExp(str) : str)\nconst canBind = prop => typeof console[prop] === 'function'\n\nexport class Consolite {\n  prefix = []\n  _filter = null\n  _level = null\n  _levels = {}\n  parent = null\n\n  constructor(...prefix) {\n    this.prefix.push(...prefix)\n\n    const withinLevel = prop => this.levels[prop] <= this.level\n    const passesFilter = () =>\n      typeof this.filter === 'function'\n        ? this.filter(prefix)\n        : prefix.join('').match(escapeIfString(this.filter))\n    const shouldPrint = prop => withinLevel(prop) && passesFilter() && canBind(prop)\n\n    // attach console methods\n    Object.keys(console).forEach(prop =>\n      Object.defineProperty(this, prop, {\n        get: () => {\n          const prefixes = prefix.map(p => typeof p === 'string' ? p : p(prop, this))\n          return shouldPrint(prop) ? console[prop].bind(console, ...prefixes) : noop\n        },\n      }),\n    )\n  }\n\n  get level() {\n    return this._level ?? this.parent?.level ?? defaults.level\n  }\n  set level(val) {\n    this._level = val\n  }\n  get filter() {\n    return this._filter ?? this.parent?.filter ?? defaults.filter\n  }\n  set filter(val) {\n    this._filter = val\n  }\n  get root() {\n    return this.parent?.root || this\n  }\n\n  levels = new Proxy(this._levels, {\n    get: (target, prop) =>\n      target[prop] ||\n      target.default ||\n      this.parent?.levels[prop] ||\n      this.parent?.levels.default ||\n      defaults.levels[prop] ||\n      defaults.levels.default,\n    set: (target, prop, value) => (target[prop] = value),\n  })\n\n  createChild(...prefix) {\n    const child = createLogger(...this.prefix, ...prefix)\n    child.parent = this\n    return child\n  }\n\n  createParent(...prefix) {\n    return createLogger(...prefix, ...this.prefix)\n  }\n\n  create = createLogger\n}\n\n/**\n * @callback PrefixFn\n * @param {string} method console method, eg. log, debug etc...\n */\n\n/** @typedef {Consolite & Console} ConsoliteLogger */\n\n/**\n * @param {(string|PrefixFn)[]} prefix\n * @returns {ConsoliteLogger}\n */\nexport const createLogger = (...prefix) => Object.assign(new Consolite(...prefix))\n\n ", "import { createLogger } from 'consolite'\nconst log = createLogger('[rf3]')\n\nexport const createRootLogger = () => {\n    Object.assign(log, loadState())\n    return new Proxy(log, {\n        get: (target, prop) => target[prop],\n        set: (target, prop, value) => {\n            target[prop] = value\n            saveState(log)\n            return false\n        },\n    })\n}\n\nexport const loadState = () => {\n    if (typeof window === 'undefined') {\n        const level = process.env.DEBUG_LEVEL\n        const filter = process.env.DEBUG_FILTER\n        return { level, filter }\n    } else {\n        return JSON.parse(localStorage.getItem('__routify.logState') || '{}')\n    }\n}\n\nexport const saveState = log => {\n    const { level, filter } = log\n    if (typeof window === 'undefined') {\n        process.env.DEBUG_LEVEL = level\n        process.env.DEBUG_FILTER = filter\n    } else localStorage.setItem('__routify.logState', JSON.stringify({ filter, level }))\n}\n\n/**\n * @template {function} T\n * @param {T} fn\n * @param {string} msg\n * @returns {T}\n */\nexport const debugWrapper =\n    (fn, msg) =>\n    /** @ts-ignore */\n    (...params) => {\n        const result = fn(...params)\n        log.debug(msg, { params, result })\n        return result\n    }\n", "import { get, writable } from 'svelte/store'\nimport { getContext } from 'svelte'\nexport * from './logger.js' // ROUTIFY-DEV-ONLY\n\n// /**\n//  * writable with subscription hooks\n//  * @param {any} value\n//  */\n// export const writable2 = value => {\n//     let subscribers = []\n//     let { set, subscribe, update } = writable(value)\n\n//     const hooks = {\n//         onSub: () => {},\n//         onUnsub: () => {},\n//         onFirstSub: () => {},\n//         onLastUnsub: () => {},\n//     }\n\n//     const newSubscribe = (run, invalidator) => {\n//         // hooks\n//         hooks.onSub()\n//         if (!subscribers.length) hooks.onFirstSub()\n\n//         const unsub = subscribe(run, invalidator)\n//         subscribers.push(unsub)\n//         return () => {\n//             hooks.onUnsub()\n//             if (subscribers.length === 1) hooks.onLastUnsub()\n\n//             subscribers = subscribers.filter(_unsub => _unsub !== unsub)\n//             unsub()\n//         }\n//     }\n\n//     return {\n//         set,\n//         subscribe: newSubscribe,\n//         update,\n//         subscribers,\n//         hooks,\n//     }\n// }\n\nexport const isDescendantElem = parent => elem => {\n    while ((elem = elem.parentNode)) if (elem === parent) return true\n    return false\n}\n\nexport const getUrlFromClick = event => {\n    const el = event.target.closest('a')\n    const href = el && el.href\n\n    if (\n        event.ctrlKey ||\n        event.metaKey ||\n        event.altKey ||\n        event.shiftKey ||\n        event.button ||\n        (event.key && event.key !== 'Enter') ||\n        event.defaultPrevented\n    )\n        return\n    if (!href || el.target || el.host !== location.host) return\n\n    const url = new URL(href)\n    const relativeUrl = url.pathname + url.search + url.hash\n\n    event.preventDefault()\n    return relativeUrl\n}\n\n// TODO ADD TEST\n/**\n *\n * @param {string} path\n * @param {Object.<string|number,string|number>} params\n * @param {function} queryHandler\n * @returns {string}\n */\nexport const pathAndParamsToUrl = (path, params = {}, queryHandler) => {\n    Object.entries(params).forEach(([key, val]) => {\n        if (path.includes(`[${key}]`)) {\n            path = path.replace(`[${key}]`, val)\n            delete params[key]\n        }\n    })\n\n    return path + queryHandler(params)\n}\n\nexport const fromEntries = iterable => {\n    return [...iterable].reduce((obj, [key, val]) => {\n        obj[key] = val\n        return obj\n    }, {})\n}\n\n/**\n *\n * @param {string} path\n * @param {Object.<string,string>} params\n * @param {QueryHandler} queryHandler\n * @returns\n */\nexport const populateUrl = (path, params, queryHandler) => {\n    /** @type {Object.<string, string>} */\n    const overloads = {}\n    Object.entries(params).forEach(([param, value]) => {\n        const RE = new RegExp(`\\\\[${param}\\\\]|\\\\:${param}`)\n        if (path.match(RE)) path = path.replace(`[${param}]`, value)\n        else overloads[param] = value\n    })\n    const query = Object.keys(overloads).length ? queryHandler.stringify(overloads) : ''\n\n    return path + query\n}\n\nexport const urlFromAddress = () =>\n    (({ pathname, search, hash }) => pathname + search + hash)(window.location)\n\nlet _globalAutoIncrementerCount = {}\nexport const autoIncrementer = (\n    storeObj = _globalAutoIncrementerCount,\n    name = '__NA',\n) => {\n    storeObj[name] = storeObj[name] || 0\n    storeObj[name]++\n    return storeObj[name]\n}\n\n/**\n * @template  T\n * @param {string} prop\n * @returns {function(T, number, T[]): boolean}\n */\nexport const distinctBy = prop => (obj, i, arr) =>\n    arr.findIndex(_obj => _obj[prop] === obj[prop]) === i\n\nexport const contexts = {\n    /** @type {Router} */\n    get router() {\n        return getContext('routify-fragment-context').route.router\n    },\n    /** @type {FragmentContext} */\n    get fragment() {\n        return getContext('routify-fragment-context')\n    },\n}\n\n/**\n * gets context if available without throwing errors outside component initialization\n * @param {string} name\n * @returns\n */\nexport const getContextMaybe = name => {\n    try {\n        return getContext(name)\n    } catch (err) {}\n}\n\n/**\n * @template T\n * @typedef {import('svelte/store').Writable<T> & {get: ()=>T}} Getable\n */\n\n/**\n * like writable, but with an added get prop\n * @template T\n * @param  {T} value\n * @param  {import('svelte/store').StartStopNotifier<T>=} start\n * @returns {Getable<T>}\n */\nexport const getable = (value, start) => {\n    const store = writable(value, start)\n    return Object.assign(store, { get: () => get(store) })\n}\n\n/**\n * checks if all route.fragments and url are identical\n * @param  {...Route} routes\n * @returns\n */\nexport const identicalRoutes = (...routes) =>\n    routes\n        .map(route => JSON.stringify([route?.allFragments, route?.url]))\n        .reduce((prev, curr) => prev === curr && curr)\n", "export class BaseReflector {\n    /** @param {Router} router */\n    constructor(router) {\n        this.router = router\n        this.log = this.router.log\n    }\n    install() {}\n    uninstall() {}\n    reflect() {}\n}\n", "const sleep = () => new Promise(requestAnimationFrame)\n\n/**\n * Calls provided callback when scroll is idle\n * @param {Number} timeout\n * @returns {Promise}\n */\nexport const scrollIsIdle = (timeout = 100) =>\n    new Promise(resolve => {\n        let scrollTimeout\n\n        const listener = async e => {\n            clearTimeout(scrollTimeout)\n            await sleep()\n            scrollTimeout = setTimeout(() => {\n                resolve()\n                removeEventListener('scroll', listener)\n            }, timeout)\n        }\n\n        addEventListener('scroll', listener)\n    })\n", "import { get, writable } from 'svelte/store'\nimport { scrollIsIdle } from './util'\n\nconst isScrolling = writable(false)\n\n/**\n * runs after each navigation\n * @param {{route: Route}} ctx\n * @param {*} history\n * @returns\n */\nconst run = ({ route }, history) => {\n    const [path, hash] = route.url.split('#')\n    const [prevPath, _prevHash] = history[0]?.url.split('#') || []\n    if (!hash) return\n\n    const scroll = async event => {\n        const samePath = path === prevPath\n        const elem = document.getElementById(hash)\n        if (elem) elem.scrollIntoView({ behavior: samePath ? 'smooth' : 'auto' })\n\n        if (samePath && elem) {\n            isScrolling.set(true)\n            await scrollIsIdle()\n            isScrolling.set(false)\n        }\n        if (!samePath && !event) {\n            // reset page scroll to hash location on every page mutation\n            // for 500 ms to avoid load jitters\n            const observer = new MutationObserver(scroll)\n            observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n                attributes: true,\n                characterData: true,\n            })\n            setTimeout(observer.disconnect.bind(observer), 500)\n        }\n    }\n\n    scroll()\n}\n\nexport const scrollHandler = { isScrolling, run }\n", "/** @returns {BrowserAdapter} */\nexport const createBrowserAdapter = opts => {\n    const delimiter = opts?.delimiter || ';'\n\n    return {\n        // Called by each router when the browser URL changes. Returns an internal URL for each respective router.\n        toRouter: (url, router) => {\n            const formatRE = router.name ? `${router.name}=(.+?)` : `(.+?)`\n            const RE = new RegExp(`(^|${delimiter})${formatRE}(${delimiter}|$)`)\n\n            const matches = url.match(RE)\n            return matches ? matches[2] : '/'\n        },\n        // compiles all router URLS into a single URL for the browser.\n        toBrowser: routers =>\n            routers\n                .map(r => (r.name ? `${r.name}=` : '') + r.url.external())\n                .join(delimiter),\n    }\n}\n", "import {\n    urlFromAddress,\n    createRootLogger, // ROUTIFY-DEV-ONLY\n    debugWrapper, // ROUTIFY-DEV-ONLY\n} from '../utils/index.js'\nimport { createBrowserAdapter } from './BrowserAdapter.js'\n\nexport class Global {\n    /** @type {RoutifyRuntime[]} */\n    instances = []\n\n    constructor() {\n        if (typeof window !== 'undefined') window['__routify'] = this\n\n        this.log = createRootLogger() // ROUTIFY-DEV-ONLY\n    }\n\n    /** @type {Router[]} */\n    get routers() {\n        return [].concat(...this.instances.map(instance => instance.routers))\n    }\n\n    browserAdapter = createBrowserAdapter()\n\n    /** @param {Router} router */\n    urlFromBrowser = router => {\n        // ROUTIFY-DEV-ONLY-START\n        if (debugWrapper)\n            return debugWrapper(\n                this.browserAdapter.toRouter,\n                'calling browserAdapter.toRouter',\n            )(urlFromAddress(), router)\n        // ROUTIFY-DEV-ONLY-END\n\n        return this.browserAdapter.toRouter(urlFromAddress(), router)\n    }\n\n    register(instance) {\n        this.instances.push(instance)\n        return this\n    }\n}\n\nexport const globalInstance = new Global()\n", "const defaultRe = /\\[(.+?)\\]/gm // matches [string]\nexport class UrlParamUtils {\n    constructor(RE = defaultRe) {\n        this.RE = RE\n    }\n\n    /**\n     * returns [\"slug\", \"id\"] from \"my[slug]and[id]\"\n     * @param {string} name\n     * @returns {string[]}\n     */\n    getFieldsFromName = name => [...name.matchAll(this.RE)].map(v => v[1])\n\n    /**\n     * converts \"my[slug]and[id]\" to /my(.+)and(.+)/gm\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    getRegexFromName = name => new RegExp('^' + name.replace(this.RE, '(.+)') + '$')\n\n    /**\n     * returns an array of values matching a regular expresion and path\n     * @param {RegExp} re\n     * @param {string} path\n     * @returns {string[]}\n     */\n    getValuesFromPath = (re, path) => (path.match(re) || []).slice(1)\n\n    /**\n     * converts (['a', 'b', 'c'], [1, 2, 3]) to {a: 1, b: 2, c: 3}\n     * @param {string[]} fields\n     * @param {string[]} values\n     * @returns\n     */\n    mapFieldsWithValues = (fields, values) =>\n        this.haveEqualLength(fields, values) &&\n        fields.reduce((map, field, index) => {\n            map[field] = values[index]\n            return map\n        }, {})\n\n    haveEqualLength = (fields, values) => {\n        if (fields.length !== values.length)\n            throw new Error(\n                'fields and values should be of same length' +\n                    `\\nfields: ${JSON.stringify(fields)}` +\n                    `\\nvalues: ${JSON.stringify(values)}`,\n            )\n        return true\n    }\n\n    // todo unused?\n    // generateParamsFromFragment(fragment) {\n    //     return this.mapFieldsWithValues(\n    //         this.getFieldsFromName(fragment.node.name),\n    //         this.getValuesFromPath(fragment.node.regex, fragment.urlFragment),\n    //     )\n    // }\n}\n", "/**\n * @template {typeof import('./Routify')['Routify']} R\n */\nexport class RNode {\n    /** @type {R['prototype']} */\n    instance\n\n    /** @type {this} */\n    parent\n\n    /** @type {Object.<string, any>} */\n    meta = {}\n\n    /** @type {String} */\n    id\n\n    /**\n     * @param {string} name\n     * @param {MixedModule} module\n     * @param {R['prototype']} instance\n     */\n    constructor(name, module, instance) {\n        this.instance = instance\n        this.name = name\n\n        instance.nodeIndex.push(this)\n        this.module = module\n        Object.defineProperty(this, 'Instance', { enumerable: false })\n        Object.defineProperty(this, 'instance', { enumerable: false })\n        Object.defineProperty(this, 'parent', { enumerable: false })\n    }\n\n    /** @param {this} child */\n    appendChild(child) {\n        child.parent = this\n    }\n\n    /**\n     * Creates a new child node\n     * Same as `node.appendChild(instance.createNode('my-node'))`\n     * @param {string} name\n     * @returns {this}\n     */\n    createChild(name, module) {\n        const node = this.instance.createNode(name, module)\n        this.appendChild(node)\n        return node\n    }\n\n    /** @returns {this[]} */\n    get descendants() {\n        return this.instance.nodeIndex.filter(node =>\n            node.ancestors.find(n => n === this),\n        )\n    }\n\n    remove() {\n        const { nodeIndex } = this.instance\n        const index = nodeIndex.findIndex(node => node === this)\n        nodeIndex.splice(index, 1)\n    }\n\n    get ancestors() {\n        let node = this\n        const ancestors = []\n        while ((node = node.parent)) ancestors.push(node)\n\n        return ancestors\n    }\n\n    get root() {\n        /** @type {this} */\n        let node = this\n        while (node.parent) node = node.parent\n        return node\n    }\n\n    get isRoot() {\n        return this === this.root\n    }\n\n    /** @returns {this[]} */\n    get children() {\n        return this.instance.nodeIndex.filter(node => node.parent === this)\n    }\n\n    /** @returns {number} */\n    get level() {\n        return (this.parent?.level || 0) + 1\n    }\n\n    /**\n     * resolve a node relative to this node\n     * @param {string} path\n     * @returns {this}\n     */\n    traverse(path) {\n        const originNode = path.startsWith('/') ? this.root : this\n\n        const steps = path\n            .split('/')\n            .filter(snip => snip !== '.')\n            .filter(Boolean)\n\n        try {\n            const target = steps.reduce(\n                (target, step) =>\n                    step === '..'\n                        ? target.parent\n                        : target.children.find(node => node.name === step),\n                originNode,\n            )\n\n            return target\n        } catch (err) {\n            console.error(\"can't resolve path\", path, 'from', this.path, '\\n', err)\n        }\n    }\n\n    toJSON() {\n        return {\n            ...this,\n            children: [...this.children],\n        }\n    }\n\n    /** @returns {string} */\n    get path() {\n        return (\n            '/' +\n            [this, ...this.ancestors]\n                .reverse()\n                .map(node => node.name)\n                .filter(Boolean)\n                .join('/')\n        )\n    }\n}\n", "import { RNode } from '../../common/RNode.js'\nimport Node from './Node.svelte'\n\n/**\n * @extends RNode<typeof import('./RoutifyRuntime')['RoutifyRuntime']>\n */\nexport class RNodeRuntime extends RNode {\n    /** @type {Object.<string,RegExp>} */\n    #regex = {}\n\n    get regex() {\n        const { name } = this\n        if (!this.#regex[name])\n            this.#regex[name] = this.instance.utils.getRegexFromName(this.name)\n        return this.#regex[name]\n    }\n\n    // save to regex key so regex gets invalidated if name changes\n    set regex(value) {\n        this.#regex[this.name] = new RegExp(value)\n    }\n\n    get children() {\n        // todo could we avoid typecasting here?\n        const nodes = /** @type {this[]} */ (this.instance.nodeIndex)\n        return nodes\n            .filter(node => node.parent === this)\n            .sort((prev, curr) => (prev.meta.order || 0) - (curr.meta.order || 0))\n    }\n\n    /** @returns {this[]} */\n    get pages() {\n        return this.children\n            .filter(node => node.name !== 'index')\n            .filter(node => !node.meta.fallback)\n            .filter(node => !node.name.startsWith('_'))\n            .filter(node => !node.name.includes('['))\n            .filter(node => !(node.meta?.order === false))\n    }\n\n    /** @ts-ignore SvelteComponentConstructor is only available in VSCode */\n    /** @returns {Promise<SvelteComponentConstructor<*, *>>} */\n    getRawComponent() {\n        return (\n            this.module &&\n            new Promise(resolve => {\n                const modulePromise = this.module()\n                const rawComponent = modulePromise.then\n                    ? modulePromise.then(r => r.default)\n                    : modulePromise.default\n                resolve(rawComponent)\n            })\n        )\n    }\n\n    /** @returns {() => Node} */\n    get component() {\n        const node = this\n\n        return function (options) {\n            options.props = {\n                ...options.props,\n                passthrough: options.props,\n                node,\n            }\n            return new Node({ ...options })\n        }\n    }\n\n    /** @param {RNodeRuntime} child  */\n    appendChild(child) {\n        if (child.instance) child.parent = this\n    }\n\n    /**\n     * @param {object} snapshotRoot\n     */\n    importTree = snapshotRoot => {\n        const queue = [[this, snapshotRoot]]\n\n        while (queue.length) {\n            const [node, snapshot] = queue.pop()\n            const { children, ...nodeSnapshot } = snapshot\n            Object.assign(node, nodeSnapshot)\n\n            // queue children\n            for (const childSnapshot of children) {\n                const childNode = node.createChild(\n                    snapshot.name || snapshot.rootName || '',\n                )\n                queue.push([childNode, childSnapshot])\n            }\n        }\n        return this\n    }\n\n    get _fallback() {\n        return this.children.find(node => node.meta.fallback) || this.parent?._fallback\n    }\n}\n", "import { RNode } from './RNode.js'\n\n/**\n * @template {typeof import('./RNode')['RNode']} N\n */\nexport class Routify {\n    Node = RNode\n    mode = 'runtime'\n\n    /** @type {N['prototype'][]} */\n    nodeIndex = []\n\n    /** @type {Object<string, RNode>} */\n    rootNodes = {}\n\n    /**\n     * @param {string=} name relative path for the node\n     * @param {any|string=} module svelte component\n     * @returns {N['prototype']}\n     */\n    createNode(name, module) {\n        return new this.Node(name, module, this)\n    }\n\n    constructor(options) {}\n}\n", "import { UrlParamUtils } from './UrlParamUtils.js'\nimport { RNodeRuntime } from './RNodeRuntime.js'\nimport { globalInstance } from '../Global/Global.js'\nimport { Routify } from '../../common/Routify.js'\n\n/**\n * @extends Routify<typeof import('./RNodeRuntime')['RNodeRuntime']>\n */\nexport class RoutifyRuntime extends Routify {\n    Node = RNodeRuntime\n    mode = 'runtime'\n\n    /**@type {Router[]} routers this instance belongs to */\n    routers = []\n\n    /** @type {Object<string, RNodeRuntime>} */\n    rootNodes = {}\n\n    constructor(options) {\n        super()\n\n        this.options = options\n        if (options.routes) {\n            this.rootNodes[options.routes.rootName || 'unnamed'] = this.createNode(\n                options.routes.rootName,\n            ).importTree(options.routes)\n        }\n        this.utils = new UrlParamUtils()\n        this.global = globalInstance.register(this)\n        Object.defineProperty(this, 'routers', { enumerable: false })\n        this.log = this.global.log\n    }\n}\n", "\n\n/**\n * @template H\n * @callback AddHookToCollection\n * @param {H} hook\n * @returns {function} unhook\n **/\n\n/**\n * @template H\n * @typedef {AddHookToCollection<H> & HooksCollectionProps<H>} HooksCollection\n */\n\n/**\n * @template H hook\n * @typedef {Object} HooksCollectionProps\n * @prop {H} run\n * @prop {H[]} hooks\n */\n\n/**\n * creates a hook collection\n * @template H\n * @return {HooksCollection<H>}\n * @example\n * const hooksCollection = createHook()\n * const unhookFn = hooksCollection(x => console.log('hello', x))\n * const unhookFn2 = hooksCollection(x => console.log('goodbye', x))\n *\n * // call hooks\n * hooksCollection.hooks.forEach(hook => hook('Jake'))\n * // logs \"hello Jake\" and \"goodbye Jake\"\n *\n * // unregister\n * unhookFn()\n * unhookFn2()\n */\nconst createHooksCollection = (runner) => {\n    /** @type {H[]} */\n    const hooks = []\n\n    /**\n     *@type {HooksCollection<H>}\n     */\n    const hooksCollection = hook => {\n        hooks.push(hook)\n        return () => hooks.splice(hooks.indexOf(hook), 1)\n    }\n\n    hooksCollection.hooks = hooks\n    hooksCollection.run = runner(hooks)\n\n    return hooksCollection\n}\n\n\n\n/**\n * @template P\n * @typedef {HooksCollection<(pri: P, ...rest)=>P>} CollectionSync\n */\n/**\n * @template P\n * @typedef {HooksCollection<(pri: P, ...rest)=>P|Promise<P>>} CollectionAsync\n */\n/**\n * @template P\n * @typedef {HooksCollection<((pri: P, ...rest)=>void)>} CollectionSyncVoid\n */\n/**\n * @template P\n * @typedef {HooksCollection<(pri: P, ...rest)=>void|Promise<void>>} CollectionAsyncVoid\n */\n\n\n/**\n * @template T\n * @param {T=} type\n * @returns {HooksCollection<T>}\n */\nexport const createPipelineCollection = (type) =>\n    // @ts-ignore\n    createHooksCollection(\n        hooks =>\n            (value, ...rest) =>\n                hooks.reduce(\n                    (pipedValue, hook) =>\n                        pipedValue?.then\n                            ? pipedValue.then(r => hook(r, ...rest))\n                            : hook(pipedValue, ...rest),\n                    value,\n                ),\n    )\n\n/**\n * @template T\n * @param {T=} type\n * @returns {CollectionSyncVoid<T>|CollectionAsyncVoid<T>}\n */\nexport const createSequenceHooksCollection = (type) =>\n    createHooksCollection(\n        hooks =>\n            (value, ...rest) => hooks.reduce(\n                (last, hook) =>\n                    last?.then ? last.then(_ => hook(value, ...rest)) : hook(value, ...rest),\n                value,\n            )\n    )\n\n/**\n * @template T\n * @param {T=} type\n * @returns {CollectionSyncVoid<T>|CollectionAsyncVoid<T>}\n */\nexport const createParallelHooksCollection = (type) =>\n    createHooksCollection(\n        hooks =>\n            (value, ...rest) =>\n                Promise.all(hooks.map(hook => hook(value, ...rest))).then(r => value),\n    )\n\n/**\n * @template T\n * @param {T=} type\n * @returns {CollectionSync<T>|CollectionAsync<T>}\n */\nexport const createGuardsCollection = (type) =>\n    // @ts-ignore\n    createHooksCollection(\n        hooks =>\n            (value, ...rest) =>\n                hooks.reduce(\n                    (pipedValue, hook) =>\n                        pipedValue?.then\n                            ? pipedValue.then(r => r && hook(r, ...rest))\n                            : pipedValue && hook(pipedValue, ...rest),\n                    value || true,\n                ),\n    )\n", "import { createSequenceHooksCollection } from 'hookar'\nimport { get } from 'svelte/store'\nimport { urlFromAddress } from '../../utils/index.js'\nimport { BaseReflector } from './ReflectorBase.js'\n\nexport class AddressReflector extends BaseReflector {\n    /** @param {Router} router */\n    constructor(router) {\n        super(router)\n        const { instance, urlRewrites } = router\n        const { urlFromBrowser, browserAdapter } = instance.global\n\n        if (!history['onPushstate']) {\n            this.log.debug('polyfill history hooks') // ROUTIFY-DEV-ONLY\n            polyfillHistory()\n        }\n\n        /** @param {('push'|'replace')} method */\n        const createStateEventHandler = method => {\n            return function (data, title, url) {\n                const routerName = data?.routify?.router ?? false\n\n                if (routerName === false) url = browserAdapter.toRouter(url, router)\n                else if (routerName !== router.name) return false\n                for (const rewrite of urlRewrites)\n                    url = rewrite.toInternal(url, { router })\n                router.url[method](url)\n            }\n        }\n\n        this.absorb = () => router.url.replace(urlFromBrowser(router))\n        this._pushstateHandler = createStateEventHandler('push')\n        this._replacestateHandler = createStateEventHandler('replace')\n        this._popstateHandler = () => router.url.pop(urlFromBrowser(router))\n    }\n\n    install() {\n        this.hooks = [\n            history['onPushstate'](this._pushstateHandler),\n            history['onReplacestate'](this._replacestateHandler),\n            history['onPopstate'](this._popstateHandler),\n        ]\n\n        if (!get(this.router.activeRoute)) this.absorb()\n        else this.reflect()\n    }\n\n    uninstall() {\n        this.hooks.forEach(unreg => unreg())\n        setTimeout(() => this.reflect())\n    }\n\n    reflect = () => {\n        const { mode } = get(this.router.activeRoute)\n        if (mode === 'popState') return false\n        const { routers, browserAdapter } = this.router.instance.global\n\n        const addressRouters = routers.filter(\n            router => router.urlReflector instanceof this.constructor,\n        )\n\n        const url = browserAdapter.toBrowser(addressRouters)\n\n        // ROUTIFY-DEV-ONLY-START\n        this.log.debug('pushing internal url to browser', {\n            mode,\n            url,\n            currentBrowserUrl: urlFromAddress(),\n            currentInternalUrl: this.router.url.internal(),\n        })\n        // ROUTIFY-DEV-ONLY-END\n\n        history[`${mode}Native`]({}, '', url)\n    }\n}\n\nfunction polyfillHistory() {\n    const hooks = {\n        /** @type {import('hookar').HooksCollection<History['pushState']>} */\n        onPushstate: createSequenceHooksCollection(),\n        /** @type {import('hookar').HooksCollection<History['replaceState']>} */\n        onReplacestate: createSequenceHooksCollection(),\n        onPopstate: createSequenceHooksCollection(),\n    }\n    Object.assign(history, hooks)\n\n    // backup native methods\n    const { pushState, replaceState } = history\n    history['pushStateNative'] = pushState\n    history['replaceStateNative'] = replaceState\n\n    history.pushState = hooks.onPushstate.run\n    history.replaceState = hooks.onReplacestate.run\n    window.addEventListener('popstate', hooks.onPopstate.run)\n\n    return true\n}\n", "import { BaseReflector } from './ReflectorBase'\n\n// todo should these extend a base class?\n\nexport class InternalReflector extends BaseReflector {}\n", "import { derived, get, writable } from 'svelte/store'\nimport { Route } from '../Route/Route.js'\nimport {\n    fromEntries,\n    urlFromAddress,\n    getContextMaybe,\n    getable,\n    identicalRoutes,\n} from '../utils/index.js'\nimport { BaseReflector } from './urlReflectors/ReflectorBase.js'\nimport { scrollHandler as sh } from '../plugins/scrollHandler/scrollHandler.js'\nimport { globalInstance } from '../Global/Global.js'\nimport { RoutifyRuntime } from '../Instance/RoutifyRuntime.js'\nimport { AddressReflector } from './urlReflectors/Address.js'\nimport { InternalReflector } from './urlReflectors/Internal.js'\nimport {\n    createGuardsCollection,\n    createPipelineCollection,\n    createSequenceHooksCollection,\n} from 'hookar'\n\n/**\n * @typedef {function({route: Route}): any} BeforeUrlChangeCallback\n * @typedef {function({route: Route}, Route[]): any} afterUrlChangeCallback\n * @typedef {function(RouteFragment[]):RouteFragment[]} BeforeRenderCallback\n * @typedef {function({router: typeof this}):void} OnDestroyRouterCallback\n */\n\n/**\n * @typedef {import('../utils/index.js').Getable<Route>} RouteStore\n *\n *\n * @typedef {Object} RouterOptions\n * @prop {RoutifyRuntime} instance\n * @prop {RNodeRuntime} rootNode\n * @prop {any} routes\n * @prop {string} name\n * @prop {UrlRewrite|UrlRewrite[]} urlRewrite\n * @prop {typeof BaseReflector} urlReflector\n * @prop { string } url initial url\n * @prop { Boolean| typeof Router } passthrough ignore clicks\n * @prop { BeforeUrlChangeCallback } beforeUrlChange\n * @prop { afterUrlChangeCallback } afterUrlChange\n * @prop { BeforeRenderCallback } beforeRender\n * @prop { OnDestroyRouterCallback } beforeDestroy\n *\n * @typedef {Object} ParentCmpCtx\n * @prop {Route} route\n * @prop {RNodeRuntime} node\n * @prop {Object.<String|Number, String|Number>} localParams\n * @prop {Object.<String|Number, any>} options\n */\n\n/**\n * @template T\n * @typedef {import('svelte/store').Readable} Readable<T>\n */\n\n/**\n * @implements {Readable<Router>}\n */\nexport class Router {\n    subscribe\n\n    /** @private is assigned in constructor  */\n    set = x => x\n\n    /** @type {RouteStore} */\n    pendingRoute = getable(null)\n    /** @type {RouteStore} */\n    activeRoute = getable(null)\n\n    #urlReflector = null\n\n    /** @type {UrlRewrite[]} */\n    urlRewrites = []\n\n    /** @type {import('hookar').HooksCollection<BeforeUrlChangeCallback>} */\n    beforeUrlChange = createGuardsCollection()\n    /** @type {import('hookar').HooksCollection<afterUrlChangeCallback>} */\n    afterUrlChange = createSequenceHooksCollection()\n    /** @type {import('hookar').HooksCollection<BeforeRenderCallback>} */\n    beforeRender = createPipelineCollection()\n    /** @type {import('hookar').HooksCollection<OnDestroyRouterCallback>} */\n    onDestroy = createSequenceHooksCollection()\n\n    parentElem = null\n\n    queryHandler = {\n        parse: search => fromEntries(new URLSearchParams(search)),\n        stringify: params => '?' + new URLSearchParams(params).toString(),\n    }\n\n    scrollHandler = sh\n\n    url = {\n        internal: () => this.url.getPending() || this.url.getActive(),\n        external: () => this.getExternalUrl(),\n        getActive: () => get(this.activeRoute)?.url,\n        getPending: () => get(this.pendingRoute)?.url,\n        toString: () => this.url.internal(),\n        set: this._setUrl,\n        push: url => this._setUrl(url, 'pushState'),\n        replace: url => this._setUrl(url, 'replaceState'),\n        pop: url => this._setUrl(url, 'popState'),\n    }\n\n    ready = (() =>\n        new Promise(resolve => {\n            let unsub\n            unsub = this.activeRoute.subscribe(route => {\n                if (route) resolve()\n                if (unsub) unsub()\n            })\n        }))()\n\n    /** @type {Route[]} */\n    history = []\n\n    /**\n     * @param {Partial<RouterOptions>} options\n     */\n    constructor(options) {\n        Object.assign(this, writable(this))\n\n        this.init(options)\n        this.params = derived(this.activeRoute, $activeRoute => $activeRoute.params)\n        // we're using setTimeout to make sure outgoing routers have been destroyed\n        // this also prevents the first router from absorbing the url from the address and\n        // then reflecting only its internal url before other routers have absorbed the url\n        this.afterUrlChange(() => {\n            setTimeout(() => this.#urlReflector.reflect())\n        })\n        this.afterUrlChange(this.scrollHandler.run)\n        this.activeRoute.get = () => get(this.activeRoute)\n        this.pendingRoute.get = () => get(this.pendingRoute)\n    }\n\n    /**\n     * @param {Partial<RouterOptions>} param1\n     */\n    init({\n        instance,\n        rootNode,\n        name,\n        routes,\n        urlRewrite,\n        urlReflector,\n        url,\n        passthrough,\n        beforeUrlChange,\n        afterUrlChange,\n        beforeRender,\n    } = {}) {\n        const parentCmpCtx = getContextMaybe('routify-fragment-context')\n\n        /** @type {RoutifyRuntime} */\n        this.instance =\n            instance ||\n            this.instance ||\n            parentCmpCtx?.route.router.instance ||\n            globalInstance.instances[0] ||\n            new RoutifyRuntime({})\n\n        this.name = name || this.name || ''\n\n        // ROUTIFY-DEV-ONLY-START\n        this.log =\n            this.log || this.instance.log.createChild(this.name || '[unnamed instance]')\n        // ROUTIFY-DEV-ONLY-END\n\n        this.urlRewrites = [urlRewrite].flat().filter(Boolean)\n\n        if (passthrough && !(passthrough instanceof Router))\n            passthrough = parentCmpCtx?.route.router || passthrough\n\n        this.passthrough = passthrough || this.passthrough\n\n        globalInstance.instances.forEach(inst => {\n            const index = inst.routers.indexOf(this)\n            if (index !== -1) inst.routers.splice(index, 1)\n        })\n\n        if (beforeUrlChange) this.beforeUrlChange(beforeUrlChange)\n        if (afterUrlChange) this.afterUrlChange(afterUrlChange)\n        if (beforeRender) this.beforeRender(beforeRender)\n\n        this.instance.routers.push(this)\n\n        if (routes) this.importRoutes(routes)\n\n        this.parentCmpCtx = parentCmpCtx\n        /** @type {RNodeRuntime} */\n        this.rootNode = rootNode || this.rootNode || this.instance.rootNodes.default\n\n        this.log.debug('initiated router') // ROUTIFY-DEV-ONLY\n        this.set(this)\n        if (this.url.getActive()) {\n            this.log.debug('router was created with activeUrl') // ROUTIFY-DEV-ONLY\n            this._setUrl(this.url.getActive(), 'pushState', true)\n        }\n\n        if (!this.urlReflector) {\n            urlReflector =\n                urlReflector ||\n                (typeof window != 'undefined' ? AddressReflector : InternalReflector)\n            this.setUrlReflector(urlReflector)\n        }\n\n        if (url) this.url.replace(url)\n    }\n\n    setParentElem = elem => (this.parentElem = elem)\n\n    importRoutes(routes) {\n        this.rootNode = this.instance.createNode().importTree(routes)\n        this.instance.rootNodes[routes.rootName || 'unnamed'] = this.rootNode\n    }\n\n    /**\n     * converts a URL or Routify's internal URL to an external URL (for the browser)\n     * @param {string=} url\n     * @returns\n     */\n    getExternalUrl = url =>\n        this.urlRewrites.reduce(\n            (_url, rewrite) => rewrite.toExternal(_url, { router: this }),\n            url || this.url.internal(),\n        )\n\n    /**\n     * converts an external URL (from the browser) to an internal URL\n     * @param {string} url\n     * @returns\n     */\n    getInternalUrl = url =>\n        this.urlRewrites.reduce(\n            (_url, rewrite) => rewrite.toInternal(_url, { router: this }),\n            url,\n        )\n\n    /**\n     *\n     * @param {string} url\n     * @param {UrlState} mode pushState, replaceState or popState\n     * @param {boolean} [isInternal=false] if the URL is already internal, skip rewrite.toInternal\n     * @returns {Promise<true|false>}\n     */\n    async _setUrl(url, mode, isInternal) {\n        if (!isInternal) url = this.getInternalUrl(url)\n\n        url = url || '/'\n        url = url.replace(/(.+)\\/+([#?]|$)/, '$1$2') // strip trailing slashes\n        const { activeRoute, pendingRoute } = this\n        const $activeRoute = activeRoute.get()\n\n        // ROUTIFY-DEV-ONLY-START\n        const { debug, groupCollapsed, trace, groupEnd } = this.log\n        if (this.log.level >= 4) {\n            const info = {\n                url,\n                mode,\n                prev: this.url.internal(),\n                browserOld: urlFromAddress(),\n            }\n            ;[groupCollapsed('set url', info), trace(), groupEnd()]\n        }\n        // ROUTIFY-DEV-ONLY-END\n\n        if (!url.startsWith('/')) url = url.replace(new URL(url).origin, '')\n\n        const route = new Route(this, url, mode)\n\n        const currentRoute = pendingRoute.get() || activeRoute.get()\n        if (identicalRoutes(currentRoute, route)) {\n            debug('current route is identical - skip', currentRoute, route) // ROUTIFY-DEV-ONLY\n            return true\n        }\n\n        route.log.debug('set pending route', route) // ROUTIFY-DEV-ONLY\n        pendingRoute.set(route)\n        await route.loadRoute()\n\n        return true\n    }\n\n    destroy() {\n        this.log.debug(`destroying router`) // ROUTIFY-DEV-ONLY\n        this.instance.routers = this.instance.routers.filter(router => router !== this)\n        this.onDestroy.run({ router: this })\n    }\n\n    /** @type {BaseReflector} */\n    get urlReflector() {\n        return this.#urlReflector\n    }\n\n    /** @param {typeof BaseReflector} UrlReflector */\n    setUrlReflector(UrlReflector) {\n        this.#urlReflector?.uninstall()\n        this.#urlReflector = new UrlReflector(this)\n        this.#urlReflector.install()\n    }\n}\n\n/**\n * Creates a new router\n * @param  {Partial<RouterOptions>} options\n */\nexport const createRouter = options => new Router(options)\n", "import { BaseReflector } from './ReflectorBase'\n\nexport class LocalStorageReflector extends BaseReflector {\n    /** @param {Router} router */\n    constructor(router) {\n        super(router)\n        this.storageName = `__routify-router-${this.router.name}`\n    }\n    reflect() {\n        window.localStorage.setItem(this.storageName, this.router.url.internal())\n    }\n}\n", "import { derived } from 'svelte/store'\nimport { pathAndParamsToUrl, contexts, populateUrl } from '../utils/index.js'\nimport { get } from 'svelte/store'\n\n/**\n * gets most recent common ancestor\n * @param {RNode} node1\n * @param {RNode} node2\n */\nexport const getMRCA = (node1, node2) => {\n    const lineage1 = [node1, ...node1.ancestors]\n    const lineage2 = [node2, ...node2.ancestors]\n    return lineage1.find(node => lineage2.includes(node))\n}\n\nexport const getPath = (node1, node2) => {\n    const lineage1 = [node1, ...node1.ancestors]\n    const lineage2 = [node2, ...node2.ancestors]\n    const mrca = getMRCA(node1, node2)\n    const backtrackSteps = lineage1.indexOf(mrca)\n    const backtrackStr = backtrackSteps ? '../'.repeat(backtrackSteps) : ''\n    const forwardSteps = lineage2.indexOf(mrca)\n    const forwardStepsStr = lineage2\n        .slice(0, forwardSteps)\n        .reverse()\n        .map(n => n.name)\n        .join('/')\n    return backtrackStr + forwardStepsStr\n}\n\n/**\n * @callback Goto\n * @param {string} path relative, absolute or named URL\n * @param {Object.<string, string>=} userParams\n * @param {any=} options\n * @type {Readable<Goto>} */\nexport const goto = {\n    subscribe: (run, invalidate) => {\n        const { router } = contexts\n        return derived(url, $url => (path, userParams, options) => {\n            const newUrl = $url(path, userParams)\n            router.url.push(newUrl)\n        }).subscribe(run, invalidate)\n    },\n}\n\n/**\n * @template T\n * @typedef {import('svelte/store').Readable<T>} Readable\n */\n\n/**\n * @typedef {Object} IsActiveOptions\n * @prop {Boolean} [recursive=true] return true if descendant is active\n */\n\n/**\n * @callback Url\n * @param {string} inputPath\n * @param {Object.<string, string>=} userParams\n * @returns {string}\n *\n * @type {Readable<Url>}\n **/\nexport const url = {\n    subscribe: (run, invalidate) => {\n        const { router } = contexts\n        let originNode = contexts.fragment.node\n        return derived(router.activeRoute, activeRoute => {\n            // in case we swapped the routes tree (rootNode), make sure we find\n            // the node that corresponds with the previous origin\n            // otherwise mrca will break as there's no shared ancestor\n            originNode = router.rootNode.traverse(originNode.path)\n            return (inputPath, userParams = {}) => {\n                // we want absolute urls to be relative to the nearest router. Ironic huh\n                const offset = inputPath.startsWith('/') ? router.rootNode.path : ''\n                const targetNode = originNode.traverse(offset + inputPath)\n                if (!targetNode) {\n                    console.error('could not find destination node', inputPath)\n                    return\n                }\n                const mrca = getMRCA(targetNode, router.rootNode)\n                const path = '/' + getPath(mrca, targetNode)\n\n                const params = {\n                    ...inheritedParams(targetNode, activeRoute),\n                    ...userParams,\n                }\n\n                const internalUrl = populateUrl(path, params, router.queryHandler)\n                return router.getExternalUrl(internalUrl)\n            }\n        }).subscribe(run, invalidate)\n    },\n}\n\n/**\n *\n * @param {RNode} node\n * @param {Route} route\n */\nconst inheritedParams = (node, route) => {\n    const lineage = [node, ...node.ancestors].reverse()\n    const params = lineage.map(\n        _node =>\n            route.fragments.find(\n                // compare both path and node\n                // node could have moved /shop/[product], eg: to /en/shop/[product]\n                // but could also have been replaced by a different, but matching node\n                // if the route tree changed, eg: /en/shop/[product] /da/shop/[product]\n                fragment => fragment.node === _node || fragment.node.path === _node.path,\n            )?.params,\n    )\n    return Object.assign({}, ...params)\n}\n\n/**\n * @type {Readable<Object.<string, any>>}\n */\nexport const params = {\n    subscribe: (run, invalidate) =>\n        derived(contexts.router.params, params => params).subscribe(run, invalidate),\n}\n\n/**\n * @callback IsActive\n * @param {String=} path\n * @param {Object.<string,string>} [params]\n * @param {IsActiveOptions} [options]\n * @returns {Boolean}\n *\n * @type {Readable<IsActive>} */\nexport const isActive = {\n    subscribe: (run, invalidate) =>\n        derived(contexts.router.activeRoute, isActiveRoute).subscribe(run, invalidate),\n}\n\nexport const isActiveRoute = $route => isActiveUrl($route.url)\n\nexport const isActiveUrl =\n    url =>\n    /** @type {IsActive} */\n    (path, params, options = {}) => {\n        const { recursive } = { recursive: true, ...options }\n        path = pathAndParamsToUrl(path, params, x => '')\n        if (recursive) path = path.replace(/\\/index\\/?$/, '')\n\n        // ensure uniform string endings to prevent /foo matching /foobar\n        return (url + '/').startsWith(path + '/')\n    }\n\n/**\n * @param {string} path\n */\nexport const resolveNode = path => {\n    const { node } = contexts.fragment\n    return path.startsWith('/')\n        ? resolveAbsoluteNode(node, path)\n        : path.startsWith('.')\n        ? traverseNode(node, path)\n        : resolveNamedNode(node, path)\n}\n\n// todo\nexport const resolveAbsoluteNode = (node, path) => {}\n\n/**\n *\n * @param {RNodeRuntime} node\n * @param {string} path\n * @returns {RNodeRuntime}\n */\nexport const traverseNode = (node, path) => node.traverse(path)\n\n// todo\nexport const resolveNamedNode = (node, name) => {}\n\nconst pseudoStore = ret => ({\n    subscribe: run => {\n        run(ret())\n        return () => {}\n    },\n})\n\n/**\n * @type {Readable<FragmentContext>}\n */\nexport const context = pseudoStore(() => contexts.fragment)\n\nexport const node = pseudoStore(() => get(context).node)\n\nexport const meta = pseudoStore(() => get(node).meta)\n\nexport const activeRoute = {\n    subscribe: run => contexts.router.activeRoute.subscribe(run),\n}\n\nexport const pendingRoute = {\n    subscribe: run => contexts.router.pendingRoute.subscribe(run),\n}\n", "/**\n * like assign, but without overwrite. First prop wins.\n * @param {object} target\n * @param  {...any} sources\n */\nconst gentleAssign = (target, ...sources) => {\n    sources.forEach(source =>\n        Object.keys(source).forEach(key => (target[key] = target[key] ?? source[key])),\n    )\n    return target\n}\n\n/**\n * deep assign node trees, will only overwrite undefined values\n * also merges meta\n * @param {RNodeBuildtime} target eg. de\n * @param {...RNodeBuildtime} sources eg. en\n */\nexport const assignNode = (target, ...sources) => {\n    // assign nodes\n    gentleAssign(target, ...sources)\n\n    // assign meta\n    gentleAssign(target.meta, ...sources.map(s => s.meta))\n\n    sources.forEach(source => {\n        source.children.forEach(sNode => {\n            let tNode = target.children.find(tNode => tNode.name === sNode.name)\n            if (!tNode) tNode = target.createChild(null, null)\n            assignNode(tNode, sNode)\n        })\n    })\n    return target\n}\n"],
  "mappings": "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",
  "names": []
}
